[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Modelovanie ekonomických procesov",
    "section": "",
    "text": "Preface\nModelovanie Ekonomických procesov",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "prednaska1_UvodCasoveRady.html",
    "href": "prednaska1_UvodCasoveRady.html",
    "title": "1  Úvod do časových radov",
    "section": "",
    "text": "1.1 Dekompozícia časových radov\nRozloženie časového radu znamená jeho rozdelenie na jednotlivé zložky, ktorými sú zvyčajne trendová zložka a nepravidelná zložka, a ak ide o sezónny časový rad, sezónna zložka.\nNesezónny časový rad pozostáva z trendovej zložky a nepravidelnej zložky. Dekompozícia časového radu zahŕňa snahu rozdeliť časový rad na tieto zložky, čiže odhadnúť trendovú zložku a nepravidelnú zložku.",
    "crumbs": [
      "Úvod do časových radov",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Úvod do časových radov</span>"
    ]
  },
  {
    "objectID": "prednaska1_UvodCasoveRady.html#dekompozícia-časových-radov",
    "href": "prednaska1_UvodCasoveRady.html#dekompozícia-časových-radov",
    "title": "1  Úvod do časových radov",
    "section": "",
    "text": "1.1.1 Trend zložka\nNa odhadnutie trendovej zložky nesezónneho časového radu, ktorý možno opísať pomocou aditívneho modelu, sa bežne používa metóda vyrovnávania (vyhladzovania), ako je napríklad výpočet jednoduchého kĺzavého priemeru časového radu.\nFunkciu SMA() (Simple Moving Average) v balíku „TTR“ (https://bookdown.org/kochiuyu/technical-analysis-with-r-second-edition/technical-indicators.html) R možno použiť na vyhladenie údajov časových radov pomocou jednoduchého kĺzavého priemeru. Ak chcete použiť túto funkciu, musíme najprv nainštalovať balík „TTR“ R (návod na inštaláciu balíka R nájdete v časti Ako nainštalovať balík R ).\nPotom môžete použiť funkciu „SMA()“ na vyhladenie údajov časových radov. Ak chcete použiť funkciu SMA(), musíte zadať poradie (rozpätie) jednoduchého kĺzavého priemeru pomocou parametra „n“. Napríklad na výpočet jednoduchého kĺzavého priemeru rádu 5 nastavíme n=5 vo funkcii SMA().\nNapríklad, ako je uvedené vyššie, časový rad počtu požičaných bicyklov za deň sa javia ako nesezónne a možno ich pravdepodobne opísať pomocou aditívneho modelu, pretože náhodné výkyvy v údajoch sú zhruba konštantné. Môžeme sa teda pokúsiť odhadnúť trendovú zložku tohto časového radu vyhladením pomocou jednoduchého kĺzavého priemeru. Na vyhladenie časového radu pomocou jednoduchého kĺzavého priemeru rádu 30 (mesiac) a vykreslenie údajov vyhladeného časového radu napíšeme:\n\ncountBikeSMA30 &lt;- SMA(countBike,n=30)\nplot.ts(countBikeSMA30,col = \"blue\")\nlines(countBike)\n\n\n\n\n\n\n\n\nÚdaje vyhladené jednoduchým kĺzavým priemerom rádu 30 poskytujú jasnejší obraz trendovej zložky a môžeme vidieť, že časové rady počtu požičaných bicyklov za deň stúpal postupne až na hodnoty okolo 7000 a začal kolísať okolo 6000 s náhodnými poklesmi pod 5000.\n\n\n1.1.2 Sezónna zložka\nSezónny časový rad pozostáva z trendovej zložky, sezónnej zložky a nepravidelnej zložky. Rozloženie časového radu znamená rozdelenie časového radu na tieto tri zložky: teda odhad týchto troch zložiek.\nNa odhadnutie trendovej zložky a sezónnej zložky sezónneho časového radu, ktoré možno opísať pomocou aditívneho modelu, môžeme použiť funkciu „decompose()“ v R. Táto funkcia odhaduje trendové, sezónne a nepravidelné zložky časového radu ktoré možno opísať pomocou aditívneho modelu.\nFunkcia „decompose()“ vráti ako výsledok objekt zoznamu, kde sú odhady sezónneho komponentu, komponentu trendu a nepravidelného komponentu uložené v pomenovaných prvkoch týchto objektov zoznamu, ktoré sa nazývajú „sezónne“, „trend“ a „náhodné“. “.\nNapríklad, ako je uvedené vyššie, časový rad počtu pôrodov za mesiac v meste New York je sezónny s vrcholom každé leto a minimom každú zimu a možno ho pravdepodobne opísať pomocou aditívneho modelu, pretože sezónne a náhodné výkyvy sa zdajú byť mať v priebehu času zhruba konštantnú veľkosť. Na odhad trendových, sezónnych a nepravidelných zložiek tohto časového radu napíšeme:\n\nbirthstscomponents &lt;- decompose(birthsts)\n\nOdhadované hodnoty sezónneho, trendového a nepravidelného komponentu sú teraz uložené v premenných komponenty birthstscomponents\\(seasonal, birthstscomponents\\)trend and birthstscomponents$random. Napríklad odhadované hodnoty sezónnej zložky môžeme vidieť zadaním:\n\n# birthstscomponents$seasonal\n\nOdhadované sezónne faktory (birthstscomponents$seasonal) sú uvedené pre mesiace január až december a sú rovnaké pre každý rok. Najväčší sezónny faktor je za júl (približne 1,46) a najnižší za február (približne -2,08), čo naznačuje, že sa zdá, že každý rok je vrchol pôrodov v júli a najnižší počet narodených vo februári.\n\n# birthstscomponents$trend\n# birthstscomponents$random\n\nOdhadovaný trend, sezónne a nepravidelné zložky časového radu môžeme vykresliť pomocou funkcie „plot()“, napríklad:\n\nplot(birthstscomponents)\n\n\n\n\n\n\n\n\nUvedený dekompozičný graf zobrazuje pôvodný časový rad mesačných pôrodov v NY, odhadovanú trendovú zložku (druhá zhora), odhadovanú sezónnu zložku (tretia zhora) a odhadovanú nepravidelnú zložku (dole). Vidíme, že zložka odhadovaného trendu vykazuje malý pokles z približne 24 tisíc v roku 1947 na približne 22 tisíc v roku 1948, po ktorom nasleduje stabilný nárast na približne 27 tisíc v roku 1959.\nAk máte sezónny časový rad, ktorý možno opísať pomocou aditívneho modelu, môžete ho sezónne upraviť odhadom sezónnej zložky a odpočítaním odhadovanej sezónnej zložky od pôvodného časového radu. Môžeme to urobiť pomocou odhadu sezónnej zložky vypočítanej funkciou „decompose()“.\nNapríklad, aby sme sezónne upravili časový rad počtu pôrodov za mesiac v New Yorku, môžeme odhadnúť sezónny komponent pomocou „decompose()“ a potom odpočítať sezónny komponent od pôvodného časového radu:\n\nbirthstsseasonallyadjusted &lt;- birthsts - head(birthstscomponents$seasonal)\n\nPotom môžeme vykresliť sezónne upravené časové rady pomocou funkcie „plot()“ zadaním:\n\nplot(birthstsseasonallyadjusted)\n\n\n\n\n\n\n\n\nMôžete vidieť, že sezónna variácia bola odstránená zo sezónne očisteného časového radu. Sezónne očistený časový rad obsahuje už len trendovú zložku a nepravidelnú zložku.",
    "crumbs": [
      "Úvod do časových radov",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Úvod do časových radov</span>"
    ]
  },
  {
    "objectID": "prednaska2_HoltWinters.html",
    "href": "prednaska2_HoltWinters.html",
    "title": "2  Holt Winters exponencálne vyrovnávanie",
    "section": "",
    "text": "2.1 Jednoduché exponenciálne vyrovnávanie\nAk máte časový rad, ktorý možno opísať pomocou aditívneho modelu s konštantnou úrovňou a bez sezónnosti, môžete použiť jednoduché exponenciálne vyhladzovanie na vytváranie krátkodobých predpovedí.\nJednoduchá metóda exponenciálneho vyhladzovania poskytuje spôsob odhadu úrovne v aktuálnom časovom bode. Vyhladzovanie je riadené parametrom alfa; pre odhad úrovne v aktuálnom časovom bode. hodnota alfa; leží medzi 0 a 1. Hodnoty alfa, ktoré sú blízke 0, znamenajú, že pri predpovediach budúcich hodnôt sa prikladá malá váha najnovším pozorovaniam.\nNa vytváranie predpovedí pomocou jednoduchého exponenciálneho vyhladzovania v jazyku R môžeme použiť jednoduchý prediktívny model exponenciálneho vyhladzovania pomocou funkcie „HoltWinters()“ v jazyku R. Ak chcete použiť HoltWinters() na jednoduché exponenciálne vyhladzovanie, musíme nastaviť parametre beta=FALSE a gamma=FALSE vo funkcii HoltWinters() (parametre beta a gama sa používajú na Holtovo exponenciálne vyhladzovanie alebo Holt-Wintersovo exponenciálne vyhladzovanie, ako je popísané nižšie). Alfa je “základná hodnota”. Vyššie alfa prikladá väčšiu váhu najnovším pozorovaniam. Beta je “trendová hodnota”. Vyššia beta znamená, že sklon trendu je viac závislý od posledných sklonov trendu. Gama je “sezónna zložka”. Vyššia gama dáva väčšiu váhu najnovším sezónnym cyklom.\nFunkcia HoltWinters() vracia premennú zoznamu, ktorá obsahuje niekoľko pomenovaných prvkov.\nNapríklad, ak chcete použiť jednoduché exponenciálne vyhladzovanie na vytváranie predpovedí pre časový rad počtu požičaných bicyklov za deň, napíšeme:\ncountBikeHW &lt;- HoltWinters(countBike, beta=FALSE, gamma=FALSE)\nVýstup HoltWinters() nám hovorí, že odhadovaná hodnota parametra alfa je približne 0.28. To je celkom ďalje od nuly, čo nám hovorí, že predpovede sú založené na nedávnych pozorovaniach.\nVo vyššie uvedenom príklade sme uložili výstup funkcie HoltWinters() do premennej zoznamu „countBikeHW“. Prognózy vytvorené HoltWinters() sú uložené v pomenovanom objekte tejto premennej listu pod názvom „fitted“, takže ich hodnoty môžeme získať zadaním:\nhead(countBikeHW$fitted)\n\n         xhat    level\n[1,]  985.000  985.000\n[2,]  932.748  932.748\n[3,] 1050.954 1050.954\n[4,] 1196.080 1196.080\n[5,] 1310.785 1310.785\n[6,] 1394.619 1394.619\nPôvodný časový rad môžeme vykresliť oproti expoeneciálnemu vyrovnávanémuu radu zadaním:\nplot(countBikeHW)\nlines(countBike)\n\n\n\n\n\n\n\ncountBikeHW$SSE\n\n[1] 680114835\nGraf zobrazuje pôvodný časový rad čiernou farbou a prognózy ako červenou čiaru. Časový rad predpovedí je oveľa plynulejší ako časový rad pôvodných údajov.\nAko mieru presnosti prognóz môžeme použiť súčet štvorcov chýb pre chyby prognóz vo vzorke, t. j. chyby prognóz za časové obdobie, ktoré pokrýva náš pôvodný časový rad. Suma štvorcov chýb je uložená v pomenovanom prvku premennej zoznamu “countBikeHW” s názvom “SSE”, takže jej hodnotu môžeme získať zadaním “countBikeHW$SSE”. Súčet štvorcov chýb je dosť vysoký.",
    "crumbs": [
      "Holt Winters exponenciálne vyrovnávanie dát",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Holt Winters exponencálne vyrovnávanie</span>"
    ]
  },
  {
    "objectID": "prednaska2_HoltWinters.html#holt-winters-prognózovanie",
    "href": "prednaska2_HoltWinters.html#holt-winters-prognózovanie",
    "title": "2  Holt Winters exponencálne vyrovnávanie",
    "section": "2.2 Holt Winters prognózovanie",
    "text": "2.2 Holt Winters prognózovanie\nPri jednoduchom exponenciálnom vyhladzovaní je bežné použiť prvú hodnotu v časovom rade ako počiatočnú hodnotu pre úroveň. Napríklad v časovom rade pre požičané bicykle je prvá dňová hodnota 985 sledovaného dvojročného obdobia. Počiatočnú hodnotu pre úroveň môžete určiť vo funkcii HoltWinters() pomocou parametra “l.start”. Ak chceme napríklad vytvoriť predpoveď s počiatočnou hodnotou hladiny nastavenou na 985, zadáme:\n\nHoltWinters(countBike, beta=FALSE, gamma=FALSE,l.start=985)\n\nHolt-Winters exponential smoothing without trend and without seasonal component.\n\nCall:\nHoltWinters(x = countBike, beta = FALSE, gamma = FALSE, l.start = 985)\n\nSmoothing parameters:\n alpha: 0.2839781\n beta : FALSE\n gamma: FALSE\n\nCoefficients:\n      [,1]\na 2121.331\n\n\nAko bolo vysvetlené vyššie, v predvolenom nastavení HoltWinters() sa predpovede vytvárajú len pre časové obdobie, ktoré pokrývajú pôvodné údaje, čo je v prípade časového radu pre požičané bicykle obdobie dvoch seldovaných rokov. Predpovede pre ďalšie časové body môžeme vytvoriť pomocou funkcie “forecast.HoltWinters()” v balíku R “forecast”. Ak chceme použiť funkciu forecast.HoltWinters(), musíme si najprv nainštalovať balík R “forecast”.\nPri použití funkcie forecast.HoltWinters() jej ako prvý argument (vstup) odovzdáte predikčný model, ktorý ste už zostavili pomocou funkcie HoltWinters(). Napríklad v prípade časového radu pre požičané bicykle sme predikčný model vytvorený pomocou funkcie HoltWinters() uložili do premennej “countBikeHW”. Pomocou parametra “h” vo funkcii forecast.HoltWinters() určíte, pre koľko ďalších časových bodov chcete vytvoriť prognózy. Napríklad, ak chceme vytvoriť predpoveď požičané bicykle na ďalšie dni (ďalších 7 dní) pomocou funkcie forecast.HoltWinters(), zadáme:\n\ncountBikeHWforecast &lt;- forecast:::forecast.HoltWinters(countBikeHW, h=7)\ncountBikeHWforecast\n\n    Point Forecast    Lo 80    Hi 80      Lo 95    Hi 95\n732       2121.331 883.5143 3359.148  228.25360 4014.409\n733       2121.331 834.5710 3408.092  153.40116 4089.262\n734       2121.331 787.4222 3455.240   81.29333 4161.369\n735       2121.331 741.8840 3500.779   11.64867 4231.014\n736       2121.331 697.8018 3544.861  -55.76922 4298.432\n737       2121.331 655.0443 3587.618 -121.16119 4363.824\n738       2121.331 613.4988 3629.164 -184.69959 4427.362\n\nsubset(countBike, start=724)\n\nTime Series:\nStart = 724 \nEnd = 731 \nFrequency = 1 \n[1]  920 1013  441 2114 3095 1341 1796 2729\n\ntail(countBikeHW$fitted,n=7)\n\nTime Series:\nStart = 725 \nEnd = 731 \nFrequency = 1 \n        xhat    level\n725 2519.953 2519.953\n726 2092.011 2092.011\n727 1623.160 1623.160\n728 1762.548 1762.548\n729 2140.935 2140.935\n730 1913.771 1913.771\n731 1880.327 1880.327\n\n\nFunkcia forecast.HoltWinters() vám poskytne predpoveď pre daný deň, 80% interval predpovede pre predpoveď a 95% interval predpovede pre predpoveď. Napríklad predpovedané dňové požičanie bicyklov na 732 deň je približne 2121 s 95 % intervalom predpovede (228, 4014).\nNa vykreslenie predpovedí vykonaných funkciou forecast.HoltWinters() môžeme použiť funkciu “plot.forecast()”:\n\nforecast:::plot.forecast(countBikeHWforecast)\n\n\n\n\n\n\n\n\n\nforecast:::plot.forecast(countBikeHWforecast)\n\n\n\n\n\n\n\n\nPredpovede na 7 dní sú tu znázornené modrou čiarou, 80 % interval predpovedí viac tmavším sivým tieňom a 95 % interval predpovedí beldším sivým tieňom.\n\n2.2.1 Holt Winters prognózovanie s odstránenou trendovou zložkou\nPredpoveď časového radu požičiavania bicyklov v prípade, že povôdný rad vyhladíme 30 dňovým jednoduchým kĺzavým priemerom:\n\ncountBikeSMA30 &lt;- SMA(countBike,n=30)\ntail(countBikeSMA30,n=10)\n\nTime Series:\nStart = 722 \nEnd = 731 \nFrequency = 1 \n [1] 4746.167 4675.400 4630.167 4583.133 4428.267 4366.767 4294.600 4161.867\n [9] 4032.800 3950.733\n\ncountBikeNoTrend &lt;- countBike - countBikeSMA30\ntail(countBikeNoTrend,n=10)\n\nTime Series:\nStart = 722 \nEnd = 731 \nFrequency = 1 \n [1] -2997.167 -2888.400 -3710.167 -3570.133 -3987.267 -2252.767 -1199.600\n [8] -2820.867 -2236.800 -1221.733\n\nplot.ts(countBikeNoTrend)\n\n\n\n\n\n\n\ncountBikeNoTrendHW &lt;- HoltWinters(subset(countBikeNoTrend, start=30), beta=FALSE, gamma=FALSE)\ncountBikeNoTrendHWforecast &lt;- forecast:::forecast.HoltWinters(countBikeNoTrendHW, h=7)\ncountBikeNoTrendHWforecast\n\n    Point Forecast     Lo 80     Hi 80     Lo 95      Hi 95\n732       -2095.39 -3320.816 -869.9639 -3969.517 -221.26258\n733       -2095.39 -3353.882 -836.8982 -4020.087 -170.69292\n734       -2095.39 -3386.101 -804.6793 -4069.362 -121.41834\n735       -2095.39 -3417.535 -773.2453 -4117.436  -73.34416\n736       -2095.39 -3448.239 -742.5415 -4164.393  -26.38670\n737       -2095.39 -3478.261 -712.5192 -4210.308   19.52842\n738       -2095.39 -3507.645 -683.1350 -4255.248   64.46768\n\nforecast:::plot.forecast(countBikeNoTrendHWforecast)\n\n\n\n\n\n\n\nsubset(countBike, start=724)\n\nTime Series:\nStart = 724 \nEnd = 731 \nFrequency = 1 \n[1]  920 1013  441 2114 3095 1341 1796 2729\n\nsubset(countBikeSMA30, start=724)\n\nTime Series:\nStart = 724 \nEnd = 731 \nFrequency = 1 \n[1] 4630.167 4583.133 4428.267 4366.767 4294.600 4161.867 4032.800 3950.733\n\n\nPotom od pôvodných hodnôt časového radu uložených v premennej “countBike” odpočítame hodnoty kĺzavého priemeru uložených v premennej “countBikeSMA30” a dostaneme nový časový rad z pôvodného, ktorý bol očistený od trendovej zložky a je uložený v premennej “countBikeNoTrend”. Nový časový trend náhodne kolíše okolo hodnoty 0, čo znamená kolísanie hodnôt okolo trendu teda hodnôt jednoduchého kĺzavého priemeru.\n\n\n2.2.2 Holt Winters prognózovanie s Box Cox transformáciou dát\nNa pôvodný časový rad požičaných biczklov uplatníme BoxCos transformáciu, kde uvažujeme lambdu=0, čo v skotočnosti je logaritmická transformácia dát a vieme, že časový rad je nazáporný a všetky hodnoty sú rôzne od nuly, potom môžme uplatniť danú transformáciu.\n\ncountBikeTransform &lt;- forecast::BoxCox(countBike,lambda=0)\nplot.ts(countBikeTransform)\n\n\n\n\n\n\n\ncountBikeTransformHW &lt;- HoltWinters(countBikeTransform,beta=FALSE, gamma=FALSE)\ncountBikeTransformHW$SSE\n\n[1] 98.21021\n\ncountBikeTransformHWforecast &lt;- forecast:::forecast.HoltWinters(countBikeTransformHW, h=7)\ncountBikeTransformHWforecast\n\n    Point Forecast    Lo 80    Hi 80    Lo 95    Hi 95\n732       7.547625 7.077270 8.017979 6.828280 8.266970\n733       7.547625 7.065362 8.029888 6.810068 8.285182\n734       7.547625 7.053741 8.041509 6.792295 8.302955\n735       7.547625 7.042387 8.052863 6.774931 8.320319\n736       7.547625 7.031283 8.063967 6.757948 8.337302\n737       7.547625 7.020412 8.074837 6.741323 8.353927\n738       7.547625 7.009762 8.085488 6.725034 8.370216\n\nforecast:::plot.forecast(countBikeTransformHWforecast)\n\n\n\n\n\n\n\n\n\n\n2.2.3 Chyba prognózy\nChyby prognózy sa vypočítajú ako pozorované hodnoty mínus predpovedané hodnoty pre každý časový bod. Chyby predpovede môžeme vypočítať len pre časové obdobie, ktoré pokrýva náš pôvodný časový rad. Ako už bolo uvedené, jedným z meradiel presnosti predpovedného modelu je súčet štvorcov chýb (SSE) pre chyby predpovede vo vzorke.\nChyby predpovede vo vzorke sú uložené v pomenovanom prvku “residuals” premennej zoznamu vrátenej funkciou forecast.HoltWinters(). Ak sa predpovedný model nedá zlepšiť, nemali by existovať žiadne korelácie medzi chybami predpovede pre po sebe nasledujúce predpovede. Inými slovami, ak existujú korelácie medzi chybami predpovedí pre po sebe nasledujúce predpovede, je pravdepodobné, že jednoduché predpovede s exponenciálnym vyhladzovaním by sa dali zlepšiť inou predpovednou technikou.\nAby sme zistili, či je to tak, môžeme získať korelogram chýb prognóz vo vzorke pre oneskorenia 1-20. Korelogram chýb prognózy môžeme vypočítať pomocou funkcie “acf()” v jazyku R. Na určenie maximálneho oneskorenia, na ktoré sa chceme pozrieť, použijeme parameter “lag.max” v funkcii acf().\nNapríklad na výpočet korelogramu chýb predpovede vo vzorke pre dňové údaje požičiavania bicyklov pre oneskorenia 1-20 zadáme:\n\nacf(subset(countBikeHWforecast$residuals,start=2), lag.max=20)\n\n\n\n\n\n\n\n\nZ korelogramu vzorky vidíte, že autokorelácia pri oneskorení 1 a 3 presahuje hranice významnosti. Ak chceme otestovať, či existuje významný dôkaz nenulovej korelácie pri oneskoreniach 1 až 20, môžeme vykonať Ljung-Boxov test. To sa dá urobiť v programe R pomocou funkcie “Box.test()”. Maximálne oneskorenie, na ktoré sa chceme pozrieť, sa špecifikuje pomocou parametra “lag” vo funkcii Box.test(). Napríklad, ak chceme otestovať, či existujú nenulové autokorelácie pri oneskoreniach 1-20, pre chyby predpovede vo vzorke požičaných bicyklov zadáme:\n\n Box.test(subset(countBikeHWforecast$residuals,start=2), lag=20, type=\"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  subset(countBikeHWforecast$residuals, start = 2)\nX-squared = 98.84, df = 20, p-value = 2.03e-12\n\n\nV tomto prípade je Ljung-Boxova testovacia štatistika 98,84 a p-hodnota je 2.03e-12, takže existuje dôkaz nenulovej autokorelácie v chybách prognózy vo vzorke s oneskorením 1-20.\nAby sme si boli istí, že prognostický model nemožno zlepšiť, je tiež dobré skontrolovať, či sú chyby prognózy normálne rozdelené so strednou hodnotou nula a konštantným rozptylom. Na overenie, či chyby prognózy majú konštantný rozptyl, môžeme urobiť časový graf chýb prognózy vo vzorke:\n\nplot.ts(subset(countBikeHWforecast$residuals,start=2))\n\n\n\n\n\n\n\n\nZ grafu vyplýva, že chyby predpovedí vo vzorke majú v čase zrejme približne konštantný rozptyl, hoci veľkosť výkyvov na začiatku časového radu môže byť o niečo menšia ako v neskorších obdobiach.\nNa overenie, či sú chyby predpovedí normálne rozdelené so strednou hodnotou nula, môžeme vykresliť histogram chýb predpovedí s prekrytou normálnou krivkou, ktorá má strednú hodnotu nula a rovnakú štandardnú odchýlku ako rozdelenie chýb predpovedí. Na tento účel môžeme definovať funkciu R “plotForecastErrors()”, ktorá je uvedená nižšie:\n\nplotForecastErrors &lt;- function(forecasterrors)\n  {\n     # histogram rezidui:\n     mybinsize &lt;- IQR(forecasterrors)/4\n     mysd   &lt;- sd(forecasterrors)\n     mymin  &lt;- min(forecasterrors) - mysd*5\n     mymax  &lt;- max(forecasterrors) + mysd*3\n     # generované štandardné normálne dáta s 0 priemerom a std 1\n     mynorm &lt;- rnorm(10000, mean=0, sd=mysd)\n     mymin2 &lt;- min(mynorm)\n     mymax2 &lt;- max(mynorm)\n     if (mymin2 &lt; mymin) { mymin &lt;- mymin2 }\n     if (mymax2 &gt; mymax) { mymax &lt;- mymax2 }\n     # červen sú reziduá a modrým sú normálne rozdelené dáta\n     mybins &lt;- seq(mymin, mymax, mybinsize)\n     hist(forecasterrors, col=\"red\", freq=FALSE, breaks=mybins)\n     # freq=FALSE zaistí, že obsah pod histogramom bude rovný  1\n     myhist &lt;- hist(mynorm, plot=FALSE, breaks=mybins)\n     points(myhist$mids, myhist$density, type=\"l\", col=\"blue\", lwd=2)\n}\n\nplotForecastErrors(subset(countBikeHWforecast$residuals,start=2))\n\n\n\n\n\n\n\nshapiro.test(subset(countBikeHWforecast$residuals,start=2))\n\n\n    Shapiro-Wilk normality test\n\ndata:  subset(countBikeHWforecast$residuals, start = 2)\nW = 0.90756, p-value &lt; 2.2e-16\n\n\nZ grafu vyplýva, že rozdelenie chýb predpovede je približne v strede nuly a je viac-menej normálne rozložené, hoci sa zdá, že v porovnaní s normálnou krivkou je mierne vychýlené doprava. Pravé skreslenie je však relatívne malé, a preto je pravdepodobné, že chyby predpovede sú normálne rozdelené so strednou hodnotou nula.\nLjungov-Boxov test ukázal, že v chybách prognózy vo vzorke existuje dôkaz nenulovej autokorelácie a zdá sa, že rozdelenie chýb prognózy je normálne rozdelené so strednou hodnotou nula. Výsledky naznačujú, že jednoduchá metóda exponenciálneho vyhladzovania neposkytuje primeraný predpovedný model pre požičiavanie bicyklov, ktorý pravdepodobne vieme inými metódami zlepšiť.\nPredpoklad ,že v chybách predpovede neexistujú autokorelácie, na ktorej boli založené 80 % a 95 % intervaly predpovedí sú neplatné. Prepoklad normality máme len graficky zatiaľ oevrenú a mali bz sme použiť test normality. Sahpiro=Wilk normality test ukázal, že dáta nie sú normlané rozdelené. Preto musíme otestovať stacionaritu radu a použiť ine nástroje časových raodv na určenie predpovede.",
    "crumbs": [
      "Holt Winters exponenciálne vyrovnávanie dát",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Holt Winters exponencálne vyrovnávanie</span>"
    ]
  },
  {
    "objectID": "prednaska3_NahodnaPrechadzkaStacionarita.html",
    "href": "prednaska3_NahodnaPrechadzkaStacionarita.html",
    "title": "3  Model bieleho šumu (white noise (WN))",
    "section": "",
    "text": "3.1 Simulácia modelu bieleho šumu\nNa simuláciu časového radu bieleho šumu možno použiť funkciu arima.sim(). ARIMA je skratka pre triedu modelov autoregresných integrovaných kĺzavých priemerov, ktoré budeme v tomto predmete uvažovať (budeme sa venovať v ARIMA modelom neskorších cvičeniach). V stručnosti si len uvedieme, čo znamenajú parametre modelu ARIMA, ktoré použijeme nižšie uvedenej funkcie. Model ARIMA(p, d, q) má tri časti, a to autoregresný rád p, rád integrácie (alebo diferencovania) d a rád kĺzavého priemeru q. Každú z týchto častí čoskoro podrobne popíšeme v neskorších cvičeniach, ale teraz si všimnime, že model ARIMA(0, 0, 0), t. j. so všetkými týmito zložkami nulovými, je jednoducho model bieleho šumu.\nJe to veľmi široká trieda modelov časových radov, ktorá zahŕňa biely šum ako špeciálny prípad. Na špecifikáciu modelu bieleho šumu použijeme špeciálny rád špecifický pre biely šum, ako je znázornené v kóde (list(order = c(0, 0, 0)). Simuluje sa rad s n rovné päťdesiatim pozorovaniam. Niektoré simulované hodnoty bieleho šumu sú zobrazené pomocou funkcie head.\nset.seed(123)\n# Simulácia n = 50 pozorovaní modelu bieleho šumu\nbielySum1 &lt;- arima.sim(model = list(order = c(0, 0, 0)), n = 50)\nhead(bielySum1)\n\n[1] -0.56047565 -0.23017749  1.55870831  0.07050839  0.12928774  1.71506499\nCelý rad simulovaného bieleho šumu je znázornený na obrázku. Predvolený priemer a štandardná odchýlka pre rad sú nula, resp. jedna.\nts.plot(bielySum1)\nSimuláciu môžete zopakovať so strednou hodnotou rovnou štyrom a štandardnou odchýlkou rovnou 2 tak, že ich pridáte ako ďalšie argumenty, ako je znázornené v kóde. Na obrázku vidíme, že simulované hodnoty oscilujú okolo hodnoty 4 (priemer) na vertikálnej osi.\nbielySum2 &lt;- arima.sim(model = list(order = c(0, 0, 0)), n = 50, mean=4,sd=2)\nhead(bielySum2)\n\n[1] 4.506637 3.942906 3.914259 6.737205 3.548458 7.032941\n\nts.plot(bielySum2)",
    "crumbs": [
      "Model Bieleho Šumu (white noise) a Náhodná Prechádzka (Random walk)",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Model bieleho šumu (white noise (WN))</span>"
    ]
  },
  {
    "objectID": "prednaska3_NahodnaPrechadzkaStacionarita.html#odhad-modelu-bieleho-šumu",
    "href": "prednaska3_NahodnaPrechadzkaStacionarita.html#odhad-modelu-bieleho-šumu",
    "title": "3  Model bieleho šumu (white noise (WN))",
    "section": "3.2 Odhad modelu bieleho šumu",
    "text": "3.2 Odhad modelu bieleho šumu\nNakoniec môžeme pre daný časový rad odhadnúť model bieleho šumu. Na to použijeme funkciu arima(), pričom najprv poskytneme údaje (premenná bielySum1), potom nastavíme rády modelu, ako je znázornené v kóde (list(order = c(0, 0, 0)).\n\narima(bielySum1, order = c(0, 0, 0))\n\n\nCall:\narima(x = bielySum1, order = c(0, 0, 0))\n\nCoefficients:\n      intercept\n         0.0344\ns.e.     0.1296\n\nsigma^2 estimated as 0.8401:  log likelihood = -66.59,  aic = 137.18\n\nmean(bielySum1)\n\n[1] 0.03440355\n\nvar(bielySum1)\n\n[1] 0.8572352\n\nsqrt(var(bielySum1))\n\n[1] 0.92587\n\n\nTáto funkcia vráti odhad strednej hodnoty alebo interceptu, ktorý je pre tento časový rad približne 0.0344, približnú štandardnú chybu tohto odhadu strednej hodnoty, v tomto prípade 0.1296, a odhad rozptylu alebo sigma kvadrát, ktorý bol 0.8401. Odhadovaná štandardná odchýlka je samozrejme odmocninou z tohto odhadu rozptylu. Alternatívne môžete použiť funkcie mean() a var() na priamy odhad parametrov strednej hodnoty 0.0344 a rozptylu modelu bieleho šumu 0.8572. Podobne môžeme spraviť aj pre druhý rad bieleho šumu reprezentovaný premenou bielySum2:\n\narima(bielySum2, order = c(0, 0, 0))\n\n\nCall:\narima(x = bielySum2, order = c(0, 0, 0))\n\nCoefficients:\n      intercept\n         4.2928\ns.e.     0.2535\n\nsigma^2 estimated as 3.214:  log likelihood = -100.13,  aic = 204.27\n\nmean(bielySum2)\n\n[1] 4.292817\n\nvar(bielySum2)\n\n[1] 3.279339\n\nsqrt(var(bielySum2))\n\n[1] 1.810894",
    "crumbs": [
      "Model Bieleho Šumu (white noise) a Náhodná Prechádzka (Random walk)",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Model bieleho šumu (white noise (WN))</span>"
    ]
  },
  {
    "objectID": "prednaska3_NahodnaPrechadzkaStacionarita.html#simulácia-modelu-náhodnej-prechádzky",
    "href": "prednaska3_NahodnaPrechadzkaStacionarita.html#simulácia-modelu-náhodnej-prechádzky",
    "title": "3  Model bieleho šumu (white noise (WN))",
    "section": "4.1 Simulácia modelu náhodnej prechádzky",
    "text": "4.1 Simulácia modelu náhodnej prechádzky\nNajprv si zadefinujeme rad náhodnej prechádzky a premennej dáme názov randomWalk. Budeme mať časovú radu o dĺžke 50, pretože biely šum 1 mal toľko hodnôt. Rad inicializujeme nulovými hodnotami. Vypočítame prvý člen radu náhodnej prechádzky keďže sme už definovali \\(Y_0\\) ako prvú hodnotu v rade, ktorá bola inicializovaná hodnotou nula. Potom využijeme iteračný cyklus “for” a dorátame jednotlivé časové kroky od 2 až po 50 rekurzívne.\n\nrandomWalk &lt;- rep(0,length(bielySum1))\n#vypočítame prvý člen radu náhodnej prechádzky  \nrandomWalk[1] &lt;- randomWalk[1] + bielySum1[1]\nfor (i in 2:length(bielySum1)) {\n    randomWalk[i] &lt;- randomWalk[i-1] + bielySum1[i]\n}\nplot(randomWalk,type=\"b\", xlab=\"čas\",ylab=\"hodnoty náhodnej prechádzky\", main=\"Náhodná prechádzka s použitím bieleho šumu 1\")\n\n\n\n\n\n\n\n\nNa obrázku genereovaného R kódom vidíme simulovanú nahodnú prechádzku.\nAk začnete s časovým radom náhodná prechádzka (randomWalk), a použijete funkciu diff() v R na výpočet rozdielového radu, výsledok tejto jednoduchej transformácie uvidíte, že rozdiely alebo zmeny či prírastky časového radu randomWalk sú radom bieleho šumu 1. Teraz sa pozrieme na priebeh prvých diferencií.\n\nprveDiffRW &lt;- diff(randomWalk)\nplot(prveDiffRW,type=\"b\",xlab=\"čas\",ylab=\"hodnoty prvých differencií náhodnej prechádzky\",main=\"Prvé differencie náhodnej prechádzky s použitím bieleho šumu 1\")\n\n\n\n\n\n\n\nmean(prveDiffRW)\n\n[1] 0.04654394\n\nvar(prveDiffRW)\n\n[1] 0.8675713\n\nsqrt(var(prveDiffRW))\n\n[1] 0.9314351\n\nmean(bielySum1[2:50])\n\n[1] 0.04654394\n\nvar(bielySum1[2:50])\n\n[1] 0.8675713\n\n\nVidíme z výsledku, že rad prvých diferencíí náhodnej prechádzky má priemer blízky nule a rozptzl blízky k 1.Graf naynačuje, že sa pôvodný rad bieleho šumu 1 a prv0 differencie náhodnej prechádzky rovanjú. Chýba nám prvý údaj lebo pri differenciácii vypadne prvý údaj.Teda overíme to tak, že vypočitame priemer a štandardnú odhchýlku pre pozorovania 2 až 50 bieleho šumu 1 a dostávame tie isté hodnoty ako pre rad prvých diferencií.",
    "crumbs": [
      "Model Bieleho Šumu (white noise) a Náhodná Prechádzka (Random walk)",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Model bieleho šumu (white noise (WN))</span>"
    ]
  },
  {
    "objectID": "prednaska3_NahodnaPrechadzkaStacionarita.html#simulácia-modelu-náhodnej-prechádzky-s-konštatným-členom-driftom",
    "href": "prednaska3_NahodnaPrechadzkaStacionarita.html#simulácia-modelu-náhodnej-prechádzky-s-konštatným-členom-driftom",
    "title": "3  Model bieleho šumu (white noise (WN))",
    "section": "4.2 Simulácia modelu náhodnej prechádzky s konštatným členom (driftom)",
    "text": "4.2 Simulácia modelu náhodnej prechádzky s konštatným členom (driftom)\nModel náhodnej prechádzky možno rozšíriť o koeficient driftu (posun, pomalá zmena). Tým sa do rekurzívneho vzorca pridá konštanta C.\n\\(Y_t = C + Y_{t-1} + \\epsilon_t\\)\nNáhodná prechádzka s driftom má dva parametre, driftovú konštantu C a sigma-kvadrát rozptylu bieleho šumu \\(\\sigma^2_{\\epsilon}\\). Aký je prvý diferenčný rad náhodnej prechádzky s driftom? Je to jednoducho konštanta plus šum, čo je proces bieleho šumu so strednou hodnotou C.\n\nc &lt;- 0.3\nrandomWalkDrift &lt;- rep(0,length(bielySum1))\n#vypočítame prvý člen radu náhodnej prechádzky \nrandomWalkDrift[1] &lt;- randomWalkDrift[1] + bielySum1[1]\nfor (i in 2:length(bielySum1)) {\n    randomWalkDrift[i] &lt;- c + randomWalkDrift[i-1] + bielySum1[i]\n}\nplot(randomWalkDrift,type=\"b\", xlab=\"čas\",ylab=\"hodnoty náhodnej prechádzky\", main=\"Náhodná prechádzka s použitím bieleho šumu 1 a driftom c=0.3\")\n\n\n\n\n\n\n\n\nVidíme, že konštanta c vlastne vytvára lineárny trend pre náhodnú prechádzku s driftom. Kedže hodnoty bieleho šumu sú malé a pohybujú sa od =2 do 2, časom je tam vidieť nejaký výkyv okolo rastúceho lineárneho trendu, ale čím bude c väčšie tým budú výkyvy okolo trendu vidieť menej lebo hodnota trednu pre daný časový bod je väčšia ako samotný biely šum. Drift teda unáša hodnoty s lineaárnym trendom rastúcim smerom ak c je kladné, klesajúcim ak c je záporné. Teraz urobme prvé differencie náhodnej prechádzky s driftom.\n\nprveDiffRWDrift &lt;- diff(randomWalkDrift)\nplot(prveDiffRWDrift,type=\"b\",xlab=\"čas\",ylab=\"hodnoty prvých differencií náhodnej prechádzky s driftom c=0.3\",main=\"Prvé differencie náhodnej prechádzky s použitím bieleho šumu 1\")\n\n\n\n\n\n\n\nmean(prveDiffRWDrift)\n\n[1] 0.3465439\n\nvar(prveDiffRWDrift)\n\n[1] 0.8675713\n\nsqrt(var(prveDiffRWDrift))\n\n[1] 0.9314351\n\nmean(bielySum1[2:50])\n\n[1] 0.04654394\n\nvar(bielySum1[2:50])\n\n[1] 0.8675713\n\n\nTakže vidíme, že prvé diferencie radu náhodnej prechádzky s driftom c=0.3 je tiež proces bieleho šumu len priemerná hodnota nieje 0, a je posunutá o konštantu c. Teraz skúsme vygenerovať biely šum so strednou hodnotou 0.3 a štandardnou odchýlkou 1.\n\nbielySumDrift &lt;- arima.sim(model = list(order = c(0, 0, 0)), n = 50, mean=0.3)\nhead(bielySumDrift)\n\n[1] -0.41040656  0.55688371  0.05330812 -0.04754260 -0.65161857  0.25497228\n\nts.plot(bielySumDrift)\n\n\n\n\n\n\n\nmean(bielySumDrift)\n\n[1] 0.04609957\n\nvar(bielySumDrift)\n\n[1] 0.9787816\n\nsqrt(var(bielySumDrift))\n\n[1] 0.9893339\n\narima(bielySumDrift, order = c(0, 0, 0))\n\n\nCall:\narima(x = bielySumDrift, order = c(0, 0, 0))\n\nCoefficients:\n      intercept\n         0.0461\ns.e.     0.1385\n\nsigma^2 estimated as 0.9592:  log likelihood = -69.91,  aic = 143.81\n\n\nVidíme, že grafy prvých differencií a bieleho šumu s driftom s priemerom 0.3 a štandardnou odhýlkou 1 sa podobajú.Odhad priemeru bieleho šumu s driftom presne nevyšiel na 0.3, ale je tam určitá chyba a teda v rámci chybz sa nachádza aj hodnota 0.3. Nemohli sme drift zvoliť väčší lebo by sme nevideli tie výkyvy okolo rastúceho trendu. Zvoľme si drift napríklad 1 a uvidíme, že prvé differencie budú radou bieleho šumu s priemerom 1.\n\nc &lt;- 1\nrandomWalkDriftVelky &lt;- rep(0,length(bielySum1))\n#vypočítame prvý člen radu náhodnej prechádzky \nrandomWalkDriftVelky[1] &lt;- randomWalkDriftVelky[1] + bielySum1[1]\nfor (i in 2:length(bielySum1)) {\n    randomWalkDriftVelky[i] &lt;- c + randomWalkDriftVelky[i-1] + bielySum1[i]\n}\nplot(randomWalkDriftVelky,type=\"b\", xlab=\"čas\",ylab=\"hodnoty náhodnej prechádzky\", main=\"Náhodná prechádzka s použitím bieleho šumu 1 a driftom c=1\")\n\n\n\n\n\n\n\nprveDiffRWDriftVelky &lt;- diff(randomWalkDriftVelky)\nplot(prveDiffRWDriftVelky,type=\"b\",xlab=\"čas\",ylab=\"hodnoty prvých differencií náhodnej prechádzky s driftom c=1\",main=\"Prvé differencie náhodnej prechádzky s použitím bieleho šumu 1\")\n\n\n\n\n\n\n\nmean(prveDiffRWDriftVelky)\n\n[1] 1.046544\n\nvar(prveDiffRWDriftVelky)\n\n[1] 0.8675713\n\nsqrt(var(prveDiffRWDriftVelky))\n\n[1] 0.9314351\n\nmean(bielySum1[2:50])\n\n[1] 0.04654394\n\nvar(bielySum1[2:50])\n\n[1] 0.8675713\n\nbielySumDriftVelky &lt;- arima.sim(model = list(order = c(0, 0, 0)), n = 50, mean=1)\nhead(bielySumDriftVelky)\n\n[1]  1.787738847  1.769042241  1.332202579 -0.008376608  0.880547393\n[6]  0.719604665\n\nts.plot(bielySumDriftVelky)\n\n\n\n\n\n\n\nmean(bielySumDriftVelky)\n\n[1] 1.038807\n\nvar(bielySumDriftVelky)\n\n[1] 0.8667145\n\nsqrt(var(bielySumDriftVelky))\n\n[1] 0.930975\n\narima(bielySumDriftVelky, order = c(0, 0, 0))\n\n\nCall:\narima(x = bielySumDriftVelky, order = c(0, 0, 0))\n\nCoefficients:\n      intercept\n         1.0388\ns.e.     0.1303\n\nsigma^2 estimated as 0.8494:  log likelihood = -66.87,  aic = 137.73\n\n\nTu už vidieť, že rozdiel prvých diferencií je biely šum s priemerom 1.",
    "crumbs": [
      "Model Bieleho Šumu (white noise) a Náhodná Prechádzka (Random walk)",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Model bieleho šumu (white noise (WN))</span>"
    ]
  },
  {
    "objectID": "prednaska4Stacionarita.html",
    "href": "prednaska4Stacionarita.html",
    "title": "4  Stacionarita časového radu",
    "section": "",
    "text": "4.1 Použivané dáta\nBudeme používať rôzne typy údajov. V tomto cvičení vykreslíme časové rady údajov a je užitočné zamyslieť sa nad tým, ako sa tieto časové rady dajú porovnať. Zamerajte sa najmä na typ trendu, sezónnosť alebo periodicitu a homoskedasticitu.\nNajprv načítame knižnice datasets, astsa and xts pomocou príkazu libarary(). Pred prvým použitím súboru údajov by ste mali použiť funkciu help(), aby ste si pozreli podrobnosti o údajoch. Ak si chcete pozrieť podrobnosti radu, použite napríklad help(JohnsonJohnson) alebo ?JohnsonJohnson.\nlibrary(datasets)\nlibrary(astsa)\nlibrary(xts)\n\nLoading required package: zoo\n\n\n\nAttaching package: 'zoo'\n\n\nThe following objects are masked from 'package:base':\n\n    as.Date, as.Date.numeric\n\n# Náhlad na dáta Southern Oscillation Index\n# Nájdete to v knižnici astsa\nhelp(soi)\n\n# Náhlad na dáta chicken sú mesačné ceny poundu kuraťa\n# Nájdete to v knižnici astsa\nhelp(chicken)\n\n# Náhlad na dáta zárobkov na akciu Johnson & Johnson \n# Nájdete to v knižnici datasets\nhelp(JohnsonJohnson)\n\n# Náhlad na dáta priemernej odchýlky  globálnej teploty medzi súšou a oceánom\n# Nájdete to v knižnici astsa\nhelp(gtemp_both)",
    "crumbs": [
      "Stacionarita časového radu",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Stacionarita časového radu</span>"
    ]
  },
  {
    "objectID": "prednaska4Stacionarita.html#stacionarita-časového-radu",
    "href": "prednaska4Stacionarita.html#stacionarita-časového-radu",
    "title": "4  Stacionarita časového radu",
    "section": "4.2 Stacionarita časového radu",
    "text": "4.2 Stacionarita časového radu\nPrejdime k základným pojmom stacionarity, jej významu a k tomu, ako prinútiť nestacionárne údaje k stacionarite.\nNa dosiahnutie úspornosti v modeli časových radov sa často predpokladá určitá forma invariantnosti rozdelenia v čase alebo stacionarity. Pre pozorovaný časový rad: Výkyvy sa javia ako náhodné. Ten istý typ náhodného správania však často platí aj medzi jednotlivými časovými obdobiami. Napríklad výnosy z akcií alebo zmeny úrokových sadzieb majú v každom z nich veľmi odlišné správanie v porovnaní s predchádzajúcim rokom. Ich priemer, štandardná odchýlka a ďalšie štatistické vlastnosti sú však často podobné v jednotlivých rokoch.\nProces (časový rad Y) je slabo stacionárny, ak sa jeho stredná hodnota, rozptyl a kovariancia časovými posunmi nemenia. To znamená, že existuje spoločná konštantná stredná hodnota mu \\(\\mu\\) a rozptyl sigma-kvadrát \\(\\sigma^2\\) pre všetky časy t.\nKovariancia medzi dátami Y v čase t a v čase s závisí len od toho, ako blízko sú časy t a s, nie od samotných časových indexov t a s. Napríklad, ak je Y stacionárny proces, potom kovariancia medzi dátami Y v časoch 2 a 5 je rovnaká ako kovariancia medzi časmi 7 a 10, pretože oba sú od seba vzdialené tri časové jednotky.\nPrečo sa zamerať na stacionárne modely? Stacionárny proces možno modelovať s oveľa menším počtom parametrov. Pre každý \\(Y_t\\) nepotrebujete inú strednú hodnotu, ale všetky majú spoločnú strednú hodnotu \\(\\mu\\), ktorú môžete presne odhadnúť pomocou \\(\\bar{y}\\), výberového priemeru.\nKeď sa pozoruje časový rad, prirodzená otázka znie: Je stacionárny? Konkrétne, je pre tento časový rad údajov vhodný model stacionárneho procesu? Mnohé finančné časové rady nevykazujú stacionaritu. Avšak: Zmeny v rade sú často približne stacionárne. Možno po použití logaritmickej transformácie. Stacionárny rad by mal vykazovať náhodné oscilácie okolo určitej pevnej úrovne, čo je jav nazývaný mean-reversion (návrat k strednej hodnote).\nV kontexte časových radov sa stacionárnosť vzťahuje na stabilitu strednej hodnoty - to znamená, že neexistuje stabilita trendu korelácie - to znamená, že korelačná štruktúra údajov zostáva v čase konštantná. Časové rady, ktoré sú tu vykreslené, môžu pomôcť lepšie pochopiť stacionaritu.  Ľavý graf je stacionárny, neexistuje v ňom žiadny trend a časový rad sa správa rovnako napríklad medzi časovými bodmi 1 až 50, 50 až 100 atď. Na druhej strane graf vpravo vyzerá veľmi odlišne medzi časovými bodmi 1 až 50 a 150 až 200. Stredné hodnoty v týchto časových intervaloch sú odlišné, rovnako ako variabilita koniec radu je variabilnejší ako začiatok.\nStacionarita znamená, že na odhad korelácie môžeme použiť jednoduché priemerovanie: Ak je stredná hodnota konštantná, potom ju môžeme odhadnúť pomocou priemeru vzorky, \\(\\bar{x}\\), a ak je korelačná štruktúra konštantná, potom napríklad na odhad korelácie s oneskorením 1 môžeme použiť všetky dvojice údajov, ktoré sú od seba vzdialené 1 časovú jednotku, \\((x_1, x_2), (x_2, x_3)\\) atď. Funguje to, pretože vzťah medzi susediacimi hodnotami radov zostáva v čase rovnaký. Podobne môžeme na odhad korelácie s oneskorením 2 použiť \\((x_1, x_3), (x_2, x_4)\\) atď.\nSouthern Oscillation Index (SOI, https://www.ncei.noaa.gov/access/monitoring/enso/soi) je pomerne stabilný. vyzerá rovnako v každom malom časovom úseku (aj keď môže existovať určitý mierny trend).\n\nplot(soi)\n\n\n\n\n\n\n\nplot(lag(soi,-1),soi)\n\n\n\n\n\n\n\nlength(lag(soi,-1))\n\n[1] 453\n\ncor(lag(soi,-1)[-1],soi[-length(soi)])\n\n[1] 0.6045049\n\nplot(lag(soi,-6),soi)\n\n\n\n\n\n\n\ndimSoi &lt;- length(soi)\nlag6Soi &lt;- length(soi) -5 \ncor(lag(soi,-6)[-c(1:6)],soi[-c(lag6Soi:length(soi))])\n\n[1] -0.1883695\n\nacf(soi)\n\n\n\n\n\n\n\n\nRozptylové grafy ukazujú koreláciu z hľadiska oneskorenia. Nazýva sa to autokorelácia a je to rovnaké ako korelácia, o ktorej ste sa učili v regresii. Graf ukazuje, že SOI, ktorý je náhradou teploty povrchu mora, je pozitívne korelovaný sám so sebou s odstupom jedného mesiaca, ale negatívne korelovaný sám so sebou s odstupom šiestich mesiacov (keďže v lete je horúco a v zime chladno).\n\nhelp(gtemp_both)\nplot(gtemp_both)\n\n\n\n\n\n\n\n\nGlobálne priemerné teplotné odchýlky medzi súšou a oceánom sú príkladom náhodnej prechádzky, kde hodnota radu v čase t je hodnota, ktorú mal v čase t-1, plus úplne náhodný pohyb.\n\nplot(diff(gtemp_both))\n\n\n\n\n\n\n\n\nDiferencovaním (“dnes mínus včera”) sa tento druh procesu môže stať stacionárnym.\n\nplot(chicken)\n\n\n\n\n\n\n\nplot(diff(chicken))\n\n\n\n\n\n\n\n\nCena kurčaťa je skôr “trendová stacionarita”, čo je stacionárne správanie okolo jednoduchého trendu. Diferencovanie funguje aj tu.\n\nplot(JohnsonJohnson)\n\n\n\n\n\n\n\nplot(log(JohnsonJohnson))\n\n\n\n\n\n\n\nplot(diff(log(JohnsonJohnson)))\n\n\n\n\n\n\n\n\nAk existuje trend a heteroskedasticita, môže pomôcť logaritnmická transformácia a diferencovanie, ako v prípade súboru údajov o štvročných zárobkoch na akciu Johnson a Johnson za obdobie od 1960 až 1980. Po prvé, logaritnmická transformácia údajov s kladnou hodnotou môže stabilizovať rozptyl. Po druhé, diferencovanie údajov dokáže odstrániť lineárny trend.",
    "crumbs": [
      "Stacionarita časového radu",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Stacionarita časového radu</span>"
    ]
  },
  {
    "objectID": "prednaska5TestovanieStacionarity.html",
    "href": "prednaska5TestovanieStacionarity.html",
    "title": "5  Testovanie stacionarity časového radu”",
    "section": "",
    "text": "5.1 Použivané dáta\nPred modelovaním časového radu údajov často chceme skontrolovať, či sú údaje stacionárne. Mnohé modely predpokladajú stacionárne časové rady, a ak je tento predpoklad porušený, naša predpoveď nebude spoľahlivá. V tomto článku sa dozvieme, ako v programe R skontrolovať stacionaritu údajov časových radov.\nNajprv načítame knižnice datasets, astsa and xts pomocou príkazu libarary(). Pred prvým použitím súboru údajov by ste mali použiť funkciu help(), aby ste si pozreli podrobnosti o údajoch. Ak si chcete pozrieť podrobnosti radu, použite napríklad help(JohnsonJohnson) alebo ?JohnsonJohnson.\nlibrary(datasets)\nlibrary(astsa)\nlibrary(xts)\n\nLoading required package: zoo\n\n\n\nAttaching package: 'zoo'\n\n\nThe following objects are masked from 'package:base':\n\n    as.Date, as.Date.numeric\n\n# Náhlad na dáta zárobkov na akciu Johnson & Johnson \n# Nájdete to v knižnici datasets\nhelp(JohnsonJohnson)\nAk existuje trend a heteroskedasticita, môže pomôcť logaritnmická transformácia a diferencovanie, ako v prípade súboru údajov o štvročných zárobkoch na akciu Johnson a Johnson za obdobie od 1960 až 1980. Po prvé, logaritnmická transformácia údajov s kladnou hodnotou môže stabilizovať rozptyl. Po druhé, diferencovanie údajov dokáže odstrániť lineárny trend.\nlibrary(datasets)\nlibrary(astsa)\nlibrary(xts)\n\n# Náhlad na dáta zárobkov na akciu Johnson & Johnson \n# Nájdete to v knižnici datasets\nhelp(JohnsonJohnson)",
    "crumbs": [
      "Testovanie stacionarity časového radu",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Testovanie stacionarity časového radu\"</span>"
    ]
  },
  {
    "objectID": "prednaska5TestovanieStacionarity.html#testy-stacionarity-časového-radu",
    "href": "prednaska5TestovanieStacionarity.html#testy-stacionarity-časového-radu",
    "title": "5  Testovanie stacionarity časového radu”",
    "section": "5.2 Testy stacionarity časového radu",
    "text": "5.2 Testy stacionarity časového radu\nPrejdime k základným testom stacionarity.\n\n5.2.1 Vizuálne kontrolovanie stacionarity časového radu\nJedným zo spôsobov, ako skontrolovať, či sú údaje stacionárne, je vykresliť ich. Tento postup by sa mal vždy používať v kombinácii s inými metódami, ale niektoré údaje ľahko vykazujú trendy a sezónnosť. Napríklad na grafe nižšie vidíme, že existuje trend smerom nahor a má aj sezónny vzor.\n\nplot(JohnsonJohnson)\n\n\n\n\n\n\n\n\n\n\n5.2.2 Augmented Dickey–Fuller Test stacionarity časového radu\nĎalším spôsobom, ako overiť, či sú údaje stacionárne, je použitie ADF testu. Týmto testom sa overí existencia jednotkového koreňa. Ak existuje jednotkový koreň, údaje nie sú stacionárne. ADF test je test s nulovou hypotézou,ktorá tvrdí, že existuje jednotkový koreň (potom je časový rad nestacionárny), a alternatívou, že neexistuje jednotkový koreň (potom je časový rad stacionárny). Na overenie môžeme použiť metódu adf.test z knižnice tseries.\n\nlibrary(tseries)\n\nRegistered S3 method overwritten by 'quantmod':\n  method            from\n  as.zoo.data.frame zoo \n\nadf.test(JohnsonJohnson)\n\nWarning in adf.test(JohnsonJohnson): p-value greater than printed p-value\n\n\n\n    Augmented Dickey-Fuller Test\n\ndata:  JohnsonJohnson\nDickey-Fuller = 1.9321, Lag order = 4, p-value = 0.99\nalternative hypothesis: stationary\n\n\nVidíme, že hodnota p-value z výstupu funckie adf.test je 0,99, čo je viac ako 0,05 a tým príjmame nulovú hypotézu. Teda štvrťročné výnosy na akciu spoločnosti Johnoson & Johnson sú nestacionárne. Možeme použiť napríklad logaritmickú transformáciu, aby sme eliminovali heteroskedasticitu z dát, teda mali konštantný rozptyl, čo je jednou z podmienok slabej stacionarity.\n\nplot(log(JohnsonJohnson))\n\n\n\n\n\n\n\nadf.test(log(JohnsonJohnson))\n\n\n    Augmented Dickey-Fuller Test\n\ndata:  log(JohnsonJohnson)\nDickey-Fuller = -1.1543, Lag order = 4, p-value = 0.9087\nalternative hypothesis: stationary\n\n\nVidíme, že hodnota p-value z výstupu funckie adf.test je 0,9087, čo je viac ako 0,05 a tým príjmame nulovú hypotézu. Teda logaritmicky transformované štvrťročné výnosy na akciu spoločnosti Johnoson & Johnson sú nestacionárne.Ešte dáta stále vykazujú rastúci lineárny trend preto odstránime lineárny trend z transformovaných dát použitím prvej diferencie.\n\nplot(diff(log(JohnsonJohnson)))\n\n\n\n\n\n\n\nadf.test(diff(log(JohnsonJohnson)))\n\nWarning in adf.test(diff(log(JohnsonJohnson))): p-value smaller than printed\np-value\n\n\n\n    Augmented Dickey-Fuller Test\n\ndata:  diff(log(JohnsonJohnson))\nDickey-Fuller = -4.5649, Lag order = 4, p-value = 0.01\nalternative hypothesis: stationary\n\n\nVidíme, že hodnota p-value z výstupu funckie adf.test je 0,01, čo je menej ako 0,05 a tým zamietame nulovú hypotézu. Teda diferencované prvým rádom logaritmicky transformované štvrťročné výnosy na akciu spoločnosti Johnoson & Johnson sú stacionárne.\n\n\n5.2.3 Ljung-Box Test stacionarity časového radu\nĎalším testom, ktorý môžeme použiť, je Ljung-Boxov test. Týmto testom overíme nezávislosť našich údajov. Ide o ďalší test hypotéz, pričom predpokladom je, že údaje sú nezávislé, teda stacionárne. Prípadne, ak dostaneme nízku p-hodnotu (väčšinou menšiu ako 0,05), môžeme zamietnuť nulovú hypotézu a predpokladať, že údaje nie sú stacionárne.\n\nBox.test(JohnsonJohnson, lag=1, type=\"Ljung-Box\") \n\n\n    Box-Ljung test\n\ndata:  JohnsonJohnson\nX-squared = 74.487, df = 1, p-value &lt; 2.2e-16\n\nBox.test(JohnsonJohnson, lag=2, type=\"Ljung-Box\") \n\n\n    Box-Ljung test\n\ndata:  JohnsonJohnson\nX-squared = 144, df = 2, p-value &lt; 2.2e-16\n\n\nVidíme, že p-value je menšia ako 0,05 teda dáta sú závislé, teda nestacionárne\n\n## odhad autokorelačnej funkcie na základe vzorca \nautoCorr &lt;- function(k,d){\n  lagk &lt;- length(d) - k\n  mu   &lt;- mean(d)\n  rad1 &lt;- lag(d,k=-k)[c(1:lagk)]\n  rad2 &lt;- d[c((k+1):length(d))]\n  cov &lt;- (rad1-mu)*(rad2-mu)\n  rn &lt;- sum(cov)*(1.0/(var(d)*(length(d)-k)))\n  rn\n}\n\n## odhad odo oka (rule of thumb) odhadneme koreláciu do lagu rovného polovičnému počtu údajov \npocetAutoCorrLagov &lt;- length(JohnsonJohnson)/2\nidx &lt;- seq(1:pocetAutoCorrLagov)\nautoCorrVals &lt;- unlist(lapply(idx,autoCorr,d=JohnsonJohnson))\nplot(autoCorrVals[c(1:19)],ylim=c(0,1))\nabline(h=0.2182)\n\n\n\n\n\n\n\nacf(JohnsonJohnson)\n\n\n\n\n\n\n\n\nUrobili sme odhad autokorelčnej funkcie pomocou vzorca. Vidíme, že štvrťročné výnosy na akciu spoločnosti Johnoson & Johnson sú silno autokorelované to znamená, že sú závislé. Podľa Ljung-Box testu vyšli závislé a teda rad je nestacionárny. Vidíme z grafu, že autokorelčná funkcia klesá.\nNulovosť autokorelačná funkcia by mala byť porovnávaná s hodnotou 0.2182.\n\n2.0/sqrt(length(JohnsonJohnson))\n\n[1] 0.2182179\n\n\nVidíme, že skoro všetky autokoreláciu sú štatisticky významné. Teda aj an základe Ljung=Box testu môžeme potvrdiť, že časový rad štvrťročných výnosov na akciu spoločnosti Johnoson & Johnson je nestacionárny.\nPotom skúsme urobiť podobnú analýzu na časovom rade aplikuje prví diferencie na logaritmicky transformované štvrťročné výnosy na akciu spoločnosti Johnoson & Johnson.\n\nBox.test(diff(log(JohnsonJohnson)), lag=1, type=\"Ljung-Box\") \n\n\n    Box-Ljung test\n\ndata:  diff(log(JohnsonJohnson))\nX-squared = 22.1, df = 1, p-value = 2.588e-06\n\nBox.test(diff(log(JohnsonJohnson)), lag=2, type=\"Ljung-Box\") \n\n\n    Box-Ljung test\n\ndata:  diff(log(JohnsonJohnson))\nX-squared = 22.492, df = 2, p-value = 1.306e-05\n\n## odhad odo oka (rule of thumb) odhadneme koreláciu do lagu rovného polovičnému počtu údajov \npocetAutoCorrLagov &lt;- length(diff(log(JohnsonJohnson)))/2\n2.0/sqrt(length(diff(log(JohnsonJohnson))))\n\n[1] 0.2195285\n\nidx &lt;- seq(1:pocetAutoCorrLagov)\nautoCorrVals &lt;- unlist(lapply(idx,autoCorr,d=diff(log(JohnsonJohnson))))\nplot(autoCorrVals[c(1:19)])\nabline(h=0.2195285)\nabline(h=-0.2195285)\n\n\n\n\n\n\n\nacf(diff(log(JohnsonJohnson)))\n\n\n\n\n\n\n\n\nVidíme, že Ljung-Box test stále potvrdil určitú závislosť medzi pozorovaniami.Hodnota autokorelácie významne poklesla po transformácii a diferencovaní. Vidieť, že niektoré lagy majú štatisticky nevýznamnú autokoreláciu. Tento časový rad z pohľadu ADF testu je stacionárny. Slabá stacionarita nevzžaduje nezávisloť údajov takže na základe ADF testu môžeme pracovať s týmto radom ako stacionárnzm a modelovať údaje pomocou ARIMA. Ak by sme neboli stále spokojný mohli by sme pokračovať ešte v teste stacionarity pomocou daľšieho testu.\n\n\n5.2.4 KPSS Test stacionarity časového radu\nNa určenie toho, či je časový rad trendovo stacionárny, možno použiť KPSS test (Kwiatkowski–Phillips–Schmidt–Shin).\nTento test používa nasledovnú nulovú a alternatívnu hypotézu:\n\nH0: Časový rad je trendovo stacionárny.\nHA: Časový rad nie je trendovo stacionárny.\n\nAk je p-hodnota testu menšia ako určitá hladina významnosti (napr. α = 0,05), potom zamietneme nulovú hypotézu a dospejeme k záveru, že časový rad nie je trendovo stacionárny.\n\nkpss.test(JohnsonJohnson, null=\"Trend\")\n\nWarning in kpss.test(JohnsonJohnson, null = \"Trend\"): p-value smaller than\nprinted p-value\n\n\n\n    KPSS Test for Trend Stationarity\n\ndata:  JohnsonJohnson\nKPSS Trend = 0.50099, Truncation lag parameter = 3, p-value = 0.01\n\nkpss.test(diff(log(JohnsonJohnson)), null=\"Trend\")\n\n\n    KPSS Test for Trend Stationarity\n\ndata:  diff(log(JohnsonJohnson))\nKPSS Trend = 0.16329, Truncation lag parameter = 3, p-value = 0.03559\n\n\nVdíme, že test kpss nepotvrdil stacionaritu u oboch časových radov pôvodného a transformovaného na prvé diferencie logaritmov pôvodného radu. Preto treba rad logaritmickej transformácie differencovať dvakrát a výsledky nížšie ukazujú, že aj ADF aj KPSS test potvrdzujú stacionaritu takého to radu. Ljung-Box test stále potvrdzuje prítomnost autokorelácie medzi transformovanými údajmi. Môžeme považovať rad dvojitej differencie na logaritmických transformovaných dátach štvročných výnosov na akciu spoločnosti Johnoson & Johnson za slabo stacionárny rad a môžeme ho používať na odhad v ARIMA modeloch.\n\nplot(diff(diff(log(JohnsonJohnson))))\n\n\n\n\n\n\n\nkpss.test(diff(diff(log(JohnsonJohnson))), null=\"Trend\")\n\nWarning in kpss.test(diff(diff(log(JohnsonJohnson))), null = \"Trend\"): p-value\ngreater than printed p-value\n\n\n\n    KPSS Test for Trend Stationarity\n\ndata:  diff(diff(log(JohnsonJohnson)))\nKPSS Trend = 0.09408, Truncation lag parameter = 3, p-value = 0.1\n\nBox.test(diff(diff(log(JohnsonJohnson))), lag=1, type=\"Ljung-Box\") \n\n\n    Box-Ljung test\n\ndata:  diff(diff(log(JohnsonJohnson)))\nX-squared = 39.394, df = 1, p-value = 3.463e-10\n\nBox.test(diff(diff(log(JohnsonJohnson))), lag=2, type=\"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  diff(diff(log(JohnsonJohnson)))\nX-squared = 48.858, df = 2, p-value = 2.458e-11\n\nadf.test(diff(diff(log(JohnsonJohnson))))\n\nWarning in adf.test(diff(diff(log(JohnsonJohnson)))): p-value smaller than\nprinted p-value\n\n\n\n    Augmented Dickey-Fuller Test\n\ndata:  diff(diff(log(JohnsonJohnson)))\nDickey-Fuller = -7.8676, Lag order = 4, p-value = 0.01\nalternative hypothesis: stationary",
    "crumbs": [
      "Testovanie stacionarity časového radu",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Testovanie stacionarity časového radu\"</span>"
    ]
  }
]